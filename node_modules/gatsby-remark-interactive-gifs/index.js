"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var path = require("path");

var visit = require("async-unist-util-visit");

var img = require("image-size");
/**
 * @typedef {object} PluginOptions
 * @property {string} dest A path in public where your gifs are stored. Absolute path.
 * @property {string} play An image to indicate that the gif can be interacted with. Absolute path.
 * @property {string} placeholder An image to show when the gif is missing in action. Absolute path.
 * @property {string} loading An image which shows when the gif is downloading. Absolute path.
 * @property {string} relativePath The relative path served to the public.
 */

/**
 * These options are used to generate the HTML node value for said gif.
 * @typedef {object} Options
 * @property {boolean} exists Indicates if the gif or placeholder needs to be embedded.
 * @property {string} relativePath? The path relative to the image file names.
 * @property {string} id? The element ID which can be set to ensure a unique gif is embedded.
 * @property {string} play? The play image file name.
 * @property {string} placeholder? The placeholder image file name.
 * @property {string} loading? The loading image file name.
 * @property {string} gif? The gif file name.
 * @property {string} still? The still image file name.
 * @property {string} caption? The caption to be embedded.
 * @property {string} class? A custom class name for the embedded gif container.
 * @property {number} width? The original width of the gif.
 * @property {number} height? The original height of the gif.
 */

/**
 * @param {string} value the inline code being parsed
 * @returns {boolean}
 */


var matchesProtocol = function matchesProtocol(value) {
  return value.startsWith("gif:");
};
/**
 * @param {string} value the inline code being parsed
 * @returns {object}
 */


var parseProtocol = function parseProtocol(value) {
  var params = value.split(":");
  var gif = params[1];
  var options = (params.length > 2 ? params[2] : "").split(";");
  var protocol = {
    gif: gif,
    id: gif,
    caption: "",
    "class": ""
  };
  options.forEach(function (opt) {
    var attribs = opt.split("=");
    protocol[attribs[0]] = attribs[1];
  });
  return protocol;
};
/**
 * @param {PluginOptions} pluginOptions
 * @param {object} params
 * @returns {object}
 */


var getNodeHtmlOptions = function getNodeHtmlOptions(pluginOptions, params) {
  var image = path.join(pluginOptions.dest, params.gif);
  var dimensions = {
    width: 0,
    height: 0
  };
  var exists = false;

  try {
    dimensions = img.imageSize(image);
    exists = true;
  } catch (e) {
    console.warn("".concat(image, " does not exist."));
  }

  return {
    exists: exists,
    relativePath: pluginOptions.relativePath,
    id: params.id,
    play: path.basename(pluginOptions.play),
    placeholder: path.basename(pluginOptions.placeholder),
    loading: path.basename(pluginOptions.loading),
    gif: params.gif,
    still: "still-".concat(params.gif),
    caption: params.caption,
    "class": params["class"],
    width: dimensions.width,
    height: dimensions.height
  };
};
/**
 * Generates the html to be embedded on the markdown page.
 * @param {Options} options
 * @returns {string}
 */


var getNodeHtml = function getNodeHtml(options) {
  if (options.exists) {
    var gifElementId = options.id;
    var stillElementId = "still-".concat(options.id);
    var responsiveness = options.height / options.width * 100;
    return "\n      <div class=\"interactive-gif ".concat(options["class"], "\">\n        <div class=\"embedded\" style=\"padding-top: ").concat(responsiveness, "%\">\n          <div id=\"loading-").concat(gifElementId, "\"\n              class=\"loading\" style=\"background-size: cover; background-image: url('").concat(options.relativePath, "/").concat(options.still, "');\">\n              <img class=\"indicator\" src=\"").concat(options.relativePath, "/").concat(options.loading, "\" />\n          </div>\n          <div id=\"").concat(gifElementId, "\"\n              class=\"gif-container\"\n              style=\"display: none;\"\n              onclick=\"document.getElementById('").concat(gifElementId, "').style.display = 'none';\n                        document.getElementById('").concat(stillElementId, "').style.display = 'block';\">\n            <img id=\"image-").concat(gifElementId, "\"\n                class=\"gif\"\n                data-original=\"").concat(options.relativePath, "/").concat(options.gif, "\" />\n          </div>\n\n          <div id=\"").concat(stillElementId, "\"\n              class=\"still-container\"\n              onclick=\"var gif = document.getElementById('image-").concat(gifElementId, "');\n                        gif.src = gif.dataset.original + '?t=' + new Date().getTime();\n                        document.getElementById('").concat(stillElementId, "').style.display = 'none';\n                        document.getElementById('").concat(gifElementId, "').style.display = 'block';\">\n            <img id=\"image-").concat(stillElementId, "\"\n                class=\"still\"\n                src=\"").concat(options.relativePath, "/").concat(options.still, "\" />\n            <img class=\"play\"\n                src=\"").concat(options.relativePath, "/").concat(options.play, "\" />\n          </div>\n        </div>\n        <div class=\"caption\">").concat(options.caption ? options.caption : "", "</div>\n      </div>\n    ");
  } else {
    return "\n      <div class=\"interactive-gif\">\n        <div class=\"placeholder\">\n          <img src=\"".concat(options.relativePath, "/").concat(options.placeholder, "\" />\n        </div>\n      </div>\n    ");
  }
};
/**
 * @param {{ markdownAST: any;}} defaultProps
 * @param {PluginOptions} pluginOptions
 * @returns {Promise}
 */


module.exports = /*#__PURE__*/function () {
  var _ref2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(_ref, pluginOptions) {
    var markdownAST;
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            markdownAST = _ref.markdownAST;
            return _context.abrupt("return", visit(markdownAST, "inlineCode", function (node) {
              var value = node.value.toString();

              if (matchesProtocol(value)) {
                var params = parseProtocol(value);
                var options = getNodeHtmlOptions(pluginOptions, params);
                var html = getNodeHtml(options);
                node = Object.assign(node, {
                  type: "html",
                  value: html
                });
              }

              return markdownAST;
            }));

          case 2:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function (_x, _x2) {
    return _ref2.apply(this, arguments);
  };
}();