"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var path = require("path");

var fs = require("fs-extra");

var gifFrames = require("gif-frames");

var sizeOf = require("image-size");

var Reporter = console;
/**
 * @typedef {object} PluginOptions
 * @property {string} root Project's working directory. Absolute path.
 * @property {string} src Where all the interactive gifs are stored. Absolute path.
 * @property {string} dest A directory in public where the gifs should be copied to. Absolute path.
 * @property {string} play The image that indicates that the gif can be interacted with. Absolute path.
 * @property {string} placeholder The image which shows when the gif is missing in action. Absolute path.
 * @property {string} loading The image which shows when the gif is downloading. Absolute path.
 */

/**
 * Verifies if the path exists.
 * @param {string} option
 * @param {string} path
 * @returns {Promise}
 */

function verifyPathExists(_x, _x2) {
  return _verifyPathExists.apply(this, arguments);
}
/**
 * Validate if all required paths exist.
 * @param {PluginOptions} pluginOptions
 * @returns {boolean}
 */


function _verifyPathExists() {
  _verifyPathExists = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(option, path) {
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", fs.pathExists(path, function (err, exists) {
              if (err || !exists) Reporter.error("Path does not exist [".concat(option, "]: ").concat(path));
              return exists;
            }));

          case 1:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _verifyPathExists.apply(this, arguments);
}

var validate = function validate(pluginOptions) {
  var verifies = [verifyPathExists("root", pluginOptions.root), verifyPathExists("src", pluginOptions.src), verifyPathExists("play", pluginOptions.play), verifyPathExists("placeholder", pluginOptions.placeholder)];
  return verifies.every(Boolean);
};
/**
 * Gets that bas64 contents of a file.
 * @param {string} pathAndfilename
 * @returns {string}
 */


var getBase64 = function getBase64(pathAndfilename) {
  return Buffer.from(fs.readFileSync(pathAndfilename)).toString("base64");
};
/**
 * Copy gifs, play and placeholder images from src to dest.
 * @param {string[]} files A list of all gif file names to be copied.
 * @param {PluginOptions} pluginOptions
 * @returns {void}
 */


var copyFiles = function copyFiles(files, pluginOptions) {
  var copy = files.map(function (filename) {
    return path.join(pluginOptions.src, filename);
  });
  copy.push(pluginOptions.play);
  copy.push(pluginOptions.placeholder);
  copy.push(pluginOptions.loading);
  copy.map(function (src) {
    var dest = path.join(pluginOptions.dest, path.basename(src));
    fs.copyFile(src, dest);
  });
};
/**
 * Create the still image from a gif.
 * @param {string} file A file name for the gif that will generate a still image from src to dest.
 * @param {PluginOptions} pluginOptions
 * @returns {void}
 */


var createStill = function createStill(file, pluginOptions) {
  var src = path.join(pluginOptions.src, file);
  var dest = path.join(pluginOptions.dest, "still-".concat(path.basename(src))); // @es-ignore

  gifFrames({
    url: src,
    frames: 0
  }) // @ts-ignore
  .then(function (frameData) {
    frameData[0].getImage().pipe(fs.createWriteStream(dest));
  });
};
/**
 * Gets the relative path of a file from its absolute path.
 * @param {string} absolutePath
 * @param {string} filePath
 * @returns {string}
 */


var getRelativePath = function getRelativePath(absolutePath, filePath) {
  return path.relative(absolutePath, filePath).replace(/public/gi, "");
};
/**
 * Create the node data.
 * @param {string} filename
 * @param {string} base64
 * @param {PluginOptions} pluginOptions
 * @returns {object}
 */


var createNodeData = function createNodeData(filename, base64, pluginOptions) {
  var src = path.join(pluginOptions.src, filename);
  var dest = path.join(pluginOptions.dest, filename);
  var still = path.join(pluginOptions.dest, "still-".concat(filename));

  var _sizeOf$imageSize = sizeOf.imageSize(src),
      width = _sizeOf$imageSize.width,
      height = _sizeOf$imageSize.height;

  var root = pluginOptions.root;
  return {
    absolutePath: dest,
    sourcePath: src,
    relativePath: getRelativePath(root, dest),
    stillRelativePath: getRelativePath(root, still),
    base64: base64,
    width: width,
    height: height
  };
};
/**
 * @param {string} filename
 * @param {string} base64
 * @param {Function} createNodeId
 * @param {Function} createContentDigest
 * @returns {object}
 */


var createNodeMeta = function createNodeMeta(filename, base64, createNodeId, createContentDigest) {
  return {
    id: createNodeId("interactive-gif-".concat(filename)),
    parent: null,
    children: [],
    internal: {
      type: "InteractiveGif",
      mediaType: "image/gif",
      content: filename,
      contentDigest: createContentDigest(base64)
    }
  };
};
/**
 * Creates the source node.
 * @param {string} filename Of the gif to be added to GraphQL.
 * @param {object} options
 * @param {PluginOptions} pluginOptions
 * @returns {void}
 */


var createSourceNode = function createSourceNode(filename, options, pluginOptions) {
  var actions = options.actions,
      createNodeId = options.createNodeId,
      createContentDigest = options.createContentDigest;
  var createNode = actions.createNode;
  var base64 = getBase64(path.join(pluginOptions.src, filename));
  var data = createNodeData(filename, base64, pluginOptions);
  var meta = createNodeMeta(filename, base64, createNodeId, createContentDigest);
  var node = Object.assign(data, meta);
  createNode(node);
};
/**
 * @param {{ reporter: object; }} options
 * @param {PluginOptions} pluginOptions
 * @returns {void}
 */


exports.sourceNodes = function (options, pluginOptions) {
  var reporter = options.reporter;
  Reporter = reporter;

  if (validate(pluginOptions)) {
    fs.mkdirp(pluginOptions.dest, function (err) {
      if (err) Reporter.error("Cannot make directory [dest]: ".concat(pluginOptions.dest, " -> ").concat(err));
    });
    fs.readdir(pluginOptions.src, function (err, files) {
      if (err) {
        Reporter.error("Cannot read directory [src]: ".concat(pluginOptions.src, " -> ").concat(err));
        return;
      }

      var gifFiles = files.filter(function (file) {
        return path.extname(file).toLowerCase() === ".gif";
      });
      copyFiles(gifFiles, pluginOptions);
      gifFiles.forEach(function (filename) {
        createStill(filename, pluginOptions);
        createSourceNode(filename, options, pluginOptions);
      });
    });
  }
};